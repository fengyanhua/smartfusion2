
FIC_MSS_CM3_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  00000000  60000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .boot_code    00000280  00000190  60000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00001100  00000410  60000410  00008410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000020  20000000  60001510  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000090  20000020  60001530  00010020  2**2
                  ALLOC
  5 .heap         0000cf50  200000b0  60001530  000100b0  2**0
                  ALLOC
  6 .stack        00003000  2000d000  60001530  00015000  2**0
                  ALLOC
  7 .comment      000000d7  00000000  00000000  00010020  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000002f8  00000000  00000000  000100f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000723  00000000  00000000  000103ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00005f66  00000000  00000000  00010b12  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000007f7  00000000  00000000  00016a78  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00001378  00000000  00000000  0001726f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000a64  00000000  00000000  000185e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00002c62  00000000  00000000  0001904c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001199  00000000  00000000  0001bcae  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 00024900  00000000  00000000  0001ce47  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  00041747  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 000002d8  00000000  00000000  0004176c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000410 <__do_global_dtors_aux>:
     410:	f240 0320 	movw	r3, #32
     414:	f2c2 0300 	movt	r3, #8192	; 0x2000
     418:	781a      	ldrb	r2, [r3, #0]
     41a:	b90a      	cbnz	r2, 420 <__do_global_dtors_aux+0x10>
     41c:	2001      	movs	r0, #1
     41e:	7018      	strb	r0, [r3, #0]
     420:	4770      	bx	lr
     422:	bf00      	nop

00000424 <frame_dummy>:
     424:	f240 0000 	movw	r0, #0
     428:	f2c2 0000 	movt	r0, #8192	; 0x2000
     42c:	b508      	push	{r3, lr}
     42e:	6803      	ldr	r3, [r0, #0]
     430:	b12b      	cbz	r3, 43e <frame_dummy+0x1a>
     432:	f240 0300 	movw	r3, #0
     436:	f2c0 0300 	movt	r3, #0
     43a:	b103      	cbz	r3, 43e <frame_dummy+0x1a>
     43c:	4798      	blx	r3
     43e:	bd08      	pop	{r3, pc}

00000440 <main>:

#define REG_APB	0x30000000
#define COREGPIO 0x5000000

  int main(void)
  {
     440:	b580      	push	{r7, lr}
     442:	b086      	sub	sp, #24
     444:	af00      	add	r7, sp, #0
     uint8_t message0[10] = "start !";
     446:	f241 33b8 	movw	r3, #5048	; 0x13b8
     44a:	f2c0 0300 	movt	r3, #0
     44e:	f107 020c 	add.w	r2, r7, #12
     452:	e893 0003 	ldmia.w	r3, {r0, r1}
     456:	e882 0003 	stmia.w	r2, {r0, r1}
     45a:	f04f 0300 	mov.w	r3, #0
     45e:	82bb      	strh	r3, [r7, #20]
     uint8_t message1[10] = "end !";
     460:	f241 32c4 	movw	r2, #5060	; 0x13c4
     464:	f2c0 0200 	movt	r2, #0
     468:	463b      	mov	r3, r7
     46a:	e892 0003 	ldmia.w	r2, {r0, r1}
     46e:	6018      	str	r0, [r3, #0]
     470:	f103 0304 	add.w	r3, r3, #4
     474:	8019      	strh	r1, [r3, #0]
     476:	f04f 0300 	mov.w	r3, #0
     47a:	80fb      	strh	r3, [r7, #6]
     47c:	f04f 0300 	mov.w	r3, #0
     480:	813b      	strh	r3, [r7, #8]
	 uint8_t data0 = 0;
     482:	f04f 0300 	mov.w	r3, #0
     486:	75fb      	strb	r3, [r7, #23]

     MSS_UART_init(&g_mss_uart0,
     488:	f240 0064 	movw	r0, #100	; 0x64
     48c:	f2c2 0000 	movt	r0, #8192	; 0x2000
     490:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     494:	f04f 0203 	mov.w	r2, #3
     498:	f000 f8ae 	bl	5f8 <MSS_UART_init>
                   MSS_UART_9600_BAUD,
                   MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);

     MSS_UART_polled_tx(&g_mss_uart0, message0, sizeof(message0));
     49c:	f107 030c 	add.w	r3, r7, #12
     4a0:	f240 0064 	movw	r0, #100	; 0x64
     4a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
     4a8:	4619      	mov	r1, r3
     4aa:	f04f 020a 	mov.w	r2, #10
     4ae:	f000 f8e5 	bl	67c <MSS_UART_polled_tx>

     *(uint32_t *)(REG_APB) = 0x65;
     4b2:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
     4b6:	f04f 0265 	mov.w	r2, #101	; 0x65
     4ba:	601a      	str	r2, [r3, #0]

     data0 = *(uint32_t *)(REG_APB);
     4bc:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
     4c0:	681b      	ldr	r3, [r3, #0]
     4c2:	75fb      	strb	r3, [r7, #23]
	 MSS_UART_polled_tx(&g_mss_uart0, data0, sizeof(data0));
     4c4:	7dfb      	ldrb	r3, [r7, #23]
     4c6:	f240 0064 	movw	r0, #100	; 0x64
     4ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
     4ce:	4619      	mov	r1, r3
     4d0:	f04f 0201 	mov.w	r2, #1
     4d4:	f000 f8d2 	bl	67c <MSS_UART_polled_tx>

     MSS_UART_polled_tx(&g_mss_uart0, message1, sizeof(message1));
     4d8:	463b      	mov	r3, r7
     4da:	f240 0064 	movw	r0, #100	; 0x64
     4de:	f2c2 0000 	movt	r0, #8192	; 0x2000
     4e2:	4619      	mov	r1, r3
     4e4:	f04f 020a 	mov.w	r2, #10
     4e8:	f000 f8c8 	bl	67c <MSS_UART_polled_tx>

     return 0;
     4ec:	f04f 0300 	mov.w	r3, #0
  }
     4f0:	4618      	mov	r0, r3
     4f2:	f107 0718 	add.w	r7, r7, #24
     4f6:	46bd      	mov	sp, r7
     4f8:	bd80      	pop	{r7, pc}
     4fa:	bf00      	nop

000004fc <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
     4fc:	b480      	push	{r7}
     4fe:	b083      	sub	sp, #12
     500:	af00      	add	r7, sp, #0
     502:	4603      	mov	r3, r0
     504:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
     506:	f24e 1300 	movw	r3, #57600	; 0xe100
     50a:	f2ce 0300 	movt	r3, #57344	; 0xe000
     50e:	f997 2007 	ldrsb.w	r2, [r7, #7]
     512:	ea4f 1252 	mov.w	r2, r2, lsr #5
     516:	79f9      	ldrb	r1, [r7, #7]
     518:	f001 011f 	and.w	r1, r1, #31
     51c:	f04f 0001 	mov.w	r0, #1
     520:	fa00 f101 	lsl.w	r1, r0, r1
     524:	f102 0260 	add.w	r2, r2, #96	; 0x60
     528:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     52c:	f107 070c 	add.w	r7, r7, #12
     530:	46bd      	mov	sp, r7
     532:	bc80      	pop	{r7}
     534:	4770      	bx	lr
     536:	bf00      	nop

00000538 <set_bit_reg8>:
static __INLINE void set_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
     538:	b480      	push	{r7}
     53a:	b083      	sub	sp, #12
     53c:	af00      	add	r7, sp, #0
     53e:	6078      	str	r0, [r7, #4]
     540:	460b      	mov	r3, r1
     542:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x1;
     544:	687b      	ldr	r3, [r7, #4]
     546:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
     54a:	687b      	ldr	r3, [r7, #4]
     54c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     550:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
     554:	ea4f 1343 	mov.w	r3, r3, lsl #5
     558:	441a      	add	r2, r3
     55a:	78fb      	ldrb	r3, [r7, #3]
     55c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     560:	4413      	add	r3, r2
     562:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
     566:	f04f 0201 	mov.w	r2, #1
     56a:	601a      	str	r2, [r3, #0]
}
     56c:	f107 070c 	add.w	r7, r7, #12
     570:	46bd      	mov	sp, r7
     572:	bc80      	pop	{r7}
     574:	4770      	bx	lr
     576:	bf00      	nop

00000578 <clear_bit_reg8>:
static __INLINE void clear_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
     578:	b480      	push	{r7}
     57a:	b083      	sub	sp, #12
     57c:	af00      	add	r7, sp, #0
     57e:	6078      	str	r0, [r7, #4]
     580:	460b      	mov	r3, r1
     582:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x0;
     584:	687b      	ldr	r3, [r7, #4]
     586:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
     58a:	687b      	ldr	r3, [r7, #4]
     58c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     590:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
     594:	ea4f 1343 	mov.w	r3, r3, lsl #5
     598:	441a      	add	r2, r3
     59a:	78fb      	ldrb	r3, [r7, #3]
     59c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     5a0:	4413      	add	r3, r2
     5a2:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
     5a6:	f04f 0200 	mov.w	r2, #0
     5aa:	601a      	str	r2, [r3, #0]
}
     5ac:	f107 070c 	add.w	r7, r7, #12
     5b0:	46bd      	mov	sp, r7
     5b2:	bc80      	pop	{r7}
     5b4:	4770      	bx	lr
     5b6:	bf00      	nop

000005b8 <read_bit_reg8>:
static __INLINE uint8_t read_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
     5b8:	b480      	push	{r7}
     5ba:	b083      	sub	sp, #12
     5bc:	af00      	add	r7, sp, #0
     5be:	6078      	str	r0, [r7, #4]
     5c0:	460b      	mov	r3, r1
     5c2:	70fb      	strb	r3, [r7, #3]
    return (HW_REG_BIT(reg,bit));
     5c4:	687b      	ldr	r3, [r7, #4]
     5c6:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
     5ca:	687b      	ldr	r3, [r7, #4]
     5cc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     5d0:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
     5d4:	ea4f 1343 	mov.w	r3, r3, lsl #5
     5d8:	441a      	add	r2, r3
     5da:	78fb      	ldrb	r3, [r7, #3]
     5dc:	ea4f 0383 	mov.w	r3, r3, lsl #2
     5e0:	4413      	add	r3, r2
     5e2:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
     5e6:	681b      	ldr	r3, [r3, #0]
     5e8:	b2db      	uxtb	r3, r3
}
     5ea:	4618      	mov	r0, r3
     5ec:	f107 070c 	add.w	r7, r7, #12
     5f0:	46bd      	mov	sp, r7
     5f2:	bc80      	pop	{r7}
     5f4:	4770      	bx	lr
     5f6:	bf00      	nop

000005f8 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
     5f8:	b580      	push	{r7, lr}
     5fa:	b084      	sub	sp, #16
     5fc:	af00      	add	r7, sp, #0
     5fe:	60f8      	str	r0, [r7, #12]
     600:	60b9      	str	r1, [r7, #8]
     602:	4613      	mov	r3, r2
     604:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
     606:	68fa      	ldr	r2, [r7, #12]
     608:	f240 0364 	movw	r3, #100	; 0x64
     60c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     610:	429a      	cmp	r2, r3
     612:	d007      	beq.n	624 <MSS_UART_init+0x2c>
     614:	68fa      	ldr	r2, [r7, #12]
     616:	f240 0324 	movw	r3, #36	; 0x24
     61a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     61e:	429a      	cmp	r2, r3
     620:	d000      	beq.n	624 <MSS_UART_init+0x2c>
     622:	be00      	bkpt	0x0000

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
     624:	79fb      	ldrb	r3, [r7, #7]
     626:	68f8      	ldr	r0, [r7, #12]
     628:	68b9      	ldr	r1, [r7, #8]
     62a:	461a      	mov	r2, r3
     62c:	f000 f988 	bl	940 <global_init>

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
     630:	68fb      	ldr	r3, [r7, #12]
     632:	681b      	ldr	r3, [r3, #0]
     634:	f103 0330 	add.w	r3, r3, #48	; 0x30
     638:	4618      	mov	r0, r3
     63a:	f04f 0103 	mov.w	r1, #3
     63e:	f7ff ff9b 	bl	578 <clear_bit_reg8>

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
     642:	68fb      	ldr	r3, [r7, #12]
     644:	681b      	ldr	r3, [r3, #0]
     646:	f103 0334 	add.w	r3, r3, #52	; 0x34
     64a:	4618      	mov	r0, r3
     64c:	f04f 0102 	mov.w	r1, #2
     650:	f7ff ff92 	bl	578 <clear_bit_reg8>

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
     654:	68fb      	ldr	r3, [r7, #12]
     656:	681b      	ldr	r3, [r3, #0]
     658:	f103 0338 	add.w	r3, r3, #56	; 0x38
     65c:	4618      	mov	r0, r3
     65e:	f04f 0100 	mov.w	r1, #0
     662:	f7ff ff89 	bl	578 <clear_bit_reg8>

    /* set default tx handler for automated TX using interrupt in USART mode */
    this_uart->tx_handler = default_tx_handler;
     666:	68fa      	ldr	r2, [r7, #12]
     668:	f640 53d9 	movw	r3, #3545	; 0xdd9
     66c:	f2c0 0300 	movt	r3, #0
     670:	6253      	str	r3, [r2, #36]	; 0x24
}
     672:	f107 0710 	add.w	r7, r7, #16
     676:	46bd      	mov	sp, r7
     678:	bd80      	pop	{r7, pc}
     67a:	bf00      	nop

0000067c <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
     67c:	b480      	push	{r7}
     67e:	b089      	sub	sp, #36	; 0x24
     680:	af00      	add	r7, sp, #0
     682:	60f8      	str	r0, [r7, #12]
     684:	60b9      	str	r1, [r7, #8]
     686:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0u;
     688:	f04f 0300 	mov.w	r3, #0
     68c:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
     68e:	68fa      	ldr	r2, [r7, #12]
     690:	f240 0364 	movw	r3, #100	; 0x64
     694:	f2c2 0300 	movt	r3, #8192	; 0x2000
     698:	429a      	cmp	r2, r3
     69a:	d007      	beq.n	6ac <MSS_UART_polled_tx+0x30>
     69c:	68fa      	ldr	r2, [r7, #12]
     69e:	f240 0324 	movw	r3, #36	; 0x24
     6a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6a6:	429a      	cmp	r2, r3
     6a8:	d000      	beq.n	6ac <MSS_UART_polled_tx+0x30>
     6aa:	be00      	bkpt	0x0000
    ASSERT(pbuff != ( (uint8_t *)0));
     6ac:	68bb      	ldr	r3, [r7, #8]
     6ae:	2b00      	cmp	r3, #0
     6b0:	d100      	bne.n	6b4 <MSS_UART_polled_tx+0x38>
     6b2:	be00      	bkpt	0x0000
    ASSERT(tx_size > 0u);
     6b4:	687b      	ldr	r3, [r7, #4]
     6b6:	2b00      	cmp	r3, #0
     6b8:	d100      	bne.n	6bc <MSS_UART_polled_tx+0x40>
     6ba:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
     6bc:	68fa      	ldr	r2, [r7, #12]
     6be:	f240 0364 	movw	r3, #100	; 0x64
     6c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6c6:	429a      	cmp	r2, r3
     6c8:	d006      	beq.n	6d8 <MSS_UART_polled_tx+0x5c>
     6ca:	68fa      	ldr	r2, [r7, #12]
     6cc:	f240 0324 	movw	r3, #36	; 0x24
     6d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6d4:	429a      	cmp	r2, r3
     6d6:	d13d      	bne.n	754 <MSS_UART_polled_tx+0xd8>
     6d8:	68bb      	ldr	r3, [r7, #8]
     6da:	2b00      	cmp	r3, #0
     6dc:	d03a      	beq.n	754 <MSS_UART_polled_tx+0xd8>
     6de:	687b      	ldr	r3, [r7, #4]
     6e0:	2b00      	cmp	r3, #0
     6e2:	d037      	beq.n	754 <MSS_UART_polled_tx+0xd8>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
     6e4:	68fb      	ldr	r3, [r7, #12]
     6e6:	681b      	ldr	r3, [r3, #0]
     6e8:	7d1b      	ldrb	r3, [r3, #20]
     6ea:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
     6ec:	68fb      	ldr	r3, [r7, #12]
     6ee:	7b5a      	ldrb	r2, [r3, #13]
     6f0:	7efb      	ldrb	r3, [r7, #27]
     6f2:	ea42 0303 	orr.w	r3, r2, r3
     6f6:	b2da      	uxtb	r2, r3
     6f8:	68fb      	ldr	r3, [r7, #12]
     6fa:	735a      	strb	r2, [r3, #13]

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
     6fc:	7efb      	ldrb	r3, [r7, #27]
     6fe:	f003 0320 	and.w	r3, r3, #32
     702:	2b00      	cmp	r3, #0
     704:	d023      	beq.n	74e <MSS_UART_polled_tx+0xd2>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
     706:	f04f 0310 	mov.w	r3, #16
     70a:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
     70c:	687b      	ldr	r3, [r7, #4]
     70e:	2b0f      	cmp	r3, #15
     710:	d801      	bhi.n	716 <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
     712:	687b      	ldr	r3, [r7, #4]
     714:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
     716:	f04f 0300 	mov.w	r3, #0
     71a:	617b      	str	r3, [r7, #20]
     71c:	e00e      	b.n	73c <MSS_UART_polled_tx+0xc0>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
     71e:	68fb      	ldr	r3, [r7, #12]
     720:	681b      	ldr	r3, [r3, #0]
     722:	68b9      	ldr	r1, [r7, #8]
     724:	693a      	ldr	r2, [r7, #16]
     726:	440a      	add	r2, r1
     728:	7812      	ldrb	r2, [r2, #0]
     72a:	701a      	strb	r2, [r3, #0]
                    char_idx++;
     72c:	693b      	ldr	r3, [r7, #16]
     72e:	f103 0301 	add.w	r3, r3, #1
     732:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
     734:	697b      	ldr	r3, [r7, #20]
     736:	f103 0301 	add.w	r3, r3, #1
     73a:	617b      	str	r3, [r7, #20]
     73c:	697a      	ldr	r2, [r7, #20]
     73e:	69fb      	ldr	r3, [r7, #28]
     740:	429a      	cmp	r2, r3
     742:	d3ec      	bcc.n	71e <MSS_UART_polled_tx+0xa2>
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
     744:	687a      	ldr	r2, [r7, #4]
     746:	697b      	ldr	r3, [r7, #20]
     748:	ebc3 0302 	rsb	r3, r3, r2
     74c:	607b      	str	r3, [r7, #4]
            }
        } while(tx_size);
     74e:	687b      	ldr	r3, [r7, #4]
     750:	2b00      	cmp	r3, #0
     752:	d1c7      	bne.n	6e4 <MSS_UART_polled_tx+0x68>
    }
}
     754:	f107 0724 	add.w	r7, r7, #36	; 0x24
     758:	46bd      	mov	sp, r7
     75a:	bc80      	pop	{r7}
     75c:	4770      	bx	lr
     75e:	bf00      	nop

00000760 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
     760:	4668      	mov	r0, sp
     762:	f020 0107 	bic.w	r1, r0, #7
     766:	468d      	mov	sp, r1
     768:	b589      	push	{r0, r3, r7, lr}
     76a:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart0);
     76c:	f240 0064 	movw	r0, #100	; 0x64
     770:	f2c2 0000 	movt	r0, #8192	; 0x2000
     774:	f000 fa1a 	bl	bac <MSS_UART_isr>
}
     778:	46bd      	mov	sp, r7
     77a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
     77e:	4685      	mov	sp, r0
     780:	4770      	bx	lr
     782:	bf00      	nop

00000784 <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
     784:	4668      	mov	r0, sp
     786:	f020 0107 	bic.w	r1, r0, #7
     78a:	468d      	mov	sp, r1
     78c:	b589      	push	{r0, r3, r7, lr}
     78e:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart1);
     790:	f240 0024 	movw	r0, #36	; 0x24
     794:	f2c2 0000 	movt	r0, #8192	; 0x2000
     798:	f000 fa08 	bl	bac <MSS_UART_isr>
}
     79c:	46bd      	mov	sp, r7
     79e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
     7a2:	4685      	mov	sp, r0
     7a4:	4770      	bx	lr
     7a6:	bf00      	nop

000007a8 <config_baud_divisors>:
config_baud_divisors
(
    mss_uart_instance_t * this_uart,
    uint32_t baudrate    
)
{
     7a8:	b580      	push	{r7, lr}
     7aa:	b088      	sub	sp, #32
     7ac:	af00      	add	r7, sp, #0
     7ae:	6078      	str	r0, [r7, #4]
     7b0:	6039      	str	r1, [r7, #0]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
     7b2:	687a      	ldr	r2, [r7, #4]
     7b4:	f240 0364 	movw	r3, #100	; 0x64
     7b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     7bc:	429a      	cmp	r2, r3
     7be:	d007      	beq.n	7d0 <config_baud_divisors+0x28>
     7c0:	687a      	ldr	r2, [r7, #4]
     7c2:	f240 0324 	movw	r3, #36	; 0x24
     7c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     7ca:	429a      	cmp	r2, r3
     7cc:	d000      	beq.n	7d0 <config_baud_divisors+0x28>
     7ce:	be00      	bkpt	0x0000
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
     7d0:	687a      	ldr	r2, [r7, #4]
     7d2:	f240 0364 	movw	r3, #100	; 0x64
     7d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     7da:	429a      	cmp	r2, r3
     7dc:	d007      	beq.n	7ee <config_baud_divisors+0x46>
     7de:	687a      	ldr	r2, [r7, #4]
     7e0:	f240 0324 	movw	r3, #36	; 0x24
     7e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     7e8:	429a      	cmp	r2, r3
     7ea:	f040 80a4 	bne.w	936 <config_baud_divisors+0x18e>
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
     7ee:	687b      	ldr	r3, [r7, #4]
     7f0:	683a      	ldr	r2, [r7, #0]
     7f2:	609a      	str	r2, [r3, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
     7f4:	f000 fbc4 	bl	f80 <SystemCoreClockUpdate>
        if(this_uart == &g_mss_uart0)
     7f8:	687a      	ldr	r2, [r7, #4]
     7fa:	f240 0364 	movw	r3, #100	; 0x64
     7fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
     802:	429a      	cmp	r2, r3
     804:	d106      	bne.n	814 <config_baud_divisors+0x6c>
        {
            pclk_freq = g_FrequencyPCLK0;
     806:	f240 0308 	movw	r3, #8
     80a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     80e:	681b      	ldr	r3, [r3, #0]
     810:	61fb      	str	r3, [r7, #28]
     812:	e005      	b.n	820 <config_baud_divisors+0x78>
        }
        else
        {
            pclk_freq = g_FrequencyPCLK1;
     814:	f240 030c 	movw	r3, #12
     818:	f2c2 0300 	movt	r3, #8192	; 0x2000
     81c:	681b      	ldr	r3, [r3, #0]
     81e:	61fb      	str	r3, [r7, #28]
        /*
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
     820:	69fb      	ldr	r3, [r7, #28]
     822:	ea4f 02c3 	mov.w	r2, r3, lsl #3
     826:	683b      	ldr	r3, [r7, #0]
     828:	fbb2 f3f3 	udiv	r3, r2, r3
     82c:	617b      	str	r3, [r7, #20]
        baud_value_by_64 = baud_value_by_128 / 2u;
     82e:	697b      	ldr	r3, [r7, #20]
     830:	ea4f 0353 	mov.w	r3, r3, lsr #1
     834:	613b      	str	r3, [r7, #16]
        baud_value = baud_value_by_64 / 64u;
     836:	693b      	ldr	r3, [r7, #16]
     838:	ea4f 1393 	mov.w	r3, r3, lsr #6
     83c:	60fb      	str	r3, [r7, #12]
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
     83e:	68fb      	ldr	r3, [r7, #12]
     840:	ea4f 1383 	mov.w	r3, r3, lsl #6
     844:	693a      	ldr	r2, [r7, #16]
     846:	ebc3 0302 	rsb	r3, r3, r2
     84a:	61bb      	str	r3, [r7, #24]
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
     84c:	68fb      	ldr	r3, [r7, #12]
     84e:	ea4f 13c3 	mov.w	r3, r3, lsl #7
     852:	697a      	ldr	r2, [r7, #20]
     854:	ebc3 0202 	rsb	r2, r3, r2
     858:	69bb      	ldr	r3, [r7, #24]
     85a:	ea4f 0343 	mov.w	r3, r3, lsl #1
     85e:	ebc3 0302 	rsb	r3, r3, r2
     862:	69ba      	ldr	r2, [r7, #24]
     864:	4413      	add	r3, r2
     866:	61bb      	str	r3, [r7, #24]
        
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
     868:	68fa      	ldr	r2, [r7, #12]
     86a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     86e:	429a      	cmp	r2, r3
     870:	d900      	bls.n	874 <config_baud_divisors+0xcc>
     872:	be00      	bkpt	0x0000
    
        if(baud_value <= (uint32_t)UINT16_MAX)
     874:	68fa      	ldr	r2, [r7, #12]
     876:	f64f 73ff 	movw	r3, #65535	; 0xffff
     87a:	429a      	cmp	r2, r3
     87c:	d85b      	bhi.n	936 <config_baud_divisors+0x18e>
        {
            if(baud_value > 1u)
     87e:	68fb      	ldr	r3, [r7, #12]
     880:	2b01      	cmp	r3, #1
     882:	d931      	bls.n	8e8 <config_baud_divisors+0x140>
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
     884:	687b      	ldr	r3, [r7, #4]
     886:	681b      	ldr	r3, [r3, #0]
     888:	f103 030c 	add.w	r3, r3, #12
     88c:	4618      	mov	r0, r3
     88e:	f04f 0107 	mov.w	r1, #7
     892:	f7ff fe51 	bl	538 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
     896:	687b      	ldr	r3, [r7, #4]
     898:	681b      	ldr	r3, [r3, #0]
     89a:	68fa      	ldr	r2, [r7, #12]
     89c:	ea4f 2212 	mov.w	r2, r2, lsr #8
     8a0:	b2d2      	uxtb	r2, r2
     8a2:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
     8a4:	687b      	ldr	r3, [r7, #4]
     8a6:	681b      	ldr	r3, [r3, #0]
     8a8:	68fa      	ldr	r2, [r7, #12]
     8aa:	b2d2      	uxtb	r2, r2
     8ac:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
     8ae:	687b      	ldr	r3, [r7, #4]
     8b0:	681b      	ldr	r3, [r3, #0]
     8b2:	f103 030c 	add.w	r3, r3, #12
     8b6:	4618      	mov	r0, r3
     8b8:	f04f 0107 	mov.w	r1, #7
     8bc:	f7ff fe5c 	bl	578 <clear_bit_reg8>
        
                /* Enable Fractional baud rate */
                set_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
     8c0:	687b      	ldr	r3, [r7, #4]
     8c2:	681b      	ldr	r3, [r3, #0]
     8c4:	f103 0330 	add.w	r3, r3, #48	; 0x30
     8c8:	4618      	mov	r0, r3
     8ca:	f04f 0107 	mov.w	r1, #7
     8ce:	f7ff fe33 	bl	538 <set_bit_reg8>
        
                /* Load the fractional baud rate register */
                ASSERT(fractional_baud_value <= (uint32_t)UINT8_MAX);
     8d2:	69bb      	ldr	r3, [r7, #24]
     8d4:	2bff      	cmp	r3, #255	; 0xff
     8d6:	d900      	bls.n	8da <config_baud_divisors+0x132>
     8d8:	be00      	bkpt	0x0000
                this_uart->hw_reg->DFR = (uint8_t)fractional_baud_value;
     8da:	687b      	ldr	r3, [r7, #4]
     8dc:	681b      	ldr	r3, [r3, #0]
     8de:	69ba      	ldr	r2, [r7, #24]
     8e0:	b2d2      	uxtb	r2, r2
     8e2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
     8e6:	e026      	b.n	936 <config_baud_divisors+0x18e>
            {
                /*
                 * Do NOT use Frational baud rate divisors.
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
     8e8:	687b      	ldr	r3, [r7, #4]
     8ea:	681b      	ldr	r3, [r3, #0]
     8ec:	f103 030c 	add.w	r3, r3, #12
     8f0:	4618      	mov	r0, r3
     8f2:	f04f 0107 	mov.w	r1, #7
     8f6:	f7ff fe1f 	bl	538 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
     8fa:	687b      	ldr	r3, [r7, #4]
     8fc:	681b      	ldr	r3, [r3, #0]
     8fe:	68fa      	ldr	r2, [r7, #12]
     900:	ea4f 2212 	mov.w	r2, r2, lsr #8
     904:	b2d2      	uxtb	r2, r2
     906:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
     908:	687b      	ldr	r3, [r7, #4]
     90a:	681b      	ldr	r3, [r3, #0]
     90c:	68fa      	ldr	r2, [r7, #12]
     90e:	b2d2      	uxtb	r2, r2
     910:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
     912:	687b      	ldr	r3, [r7, #4]
     914:	681b      	ldr	r3, [r3, #0]
     916:	f103 030c 	add.w	r3, r3, #12
     91a:	4618      	mov	r0, r3
     91c:	f04f 0107 	mov.w	r1, #7
     920:	f7ff fe2a 	bl	578 <clear_bit_reg8>
                
                /* Disable Fractional baud rate */
                clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
     924:	687b      	ldr	r3, [r7, #4]
     926:	681b      	ldr	r3, [r3, #0]
     928:	f103 0330 	add.w	r3, r3, #48	; 0x30
     92c:	4618      	mov	r0, r3
     92e:	f04f 0107 	mov.w	r1, #7
     932:	f7ff fe21 	bl	578 <clear_bit_reg8>
            }
        }
    }
}
     936:	f107 0720 	add.w	r7, r7, #32
     93a:	46bd      	mov	sp, r7
     93c:	bd80      	pop	{r7, pc}
     93e:	bf00      	nop

00000940 <global_init>:
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
     940:	b580      	push	{r7, lr}
     942:	b084      	sub	sp, #16
     944:	af00      	add	r7, sp, #0
     946:	60f8      	str	r0, [r7, #12]
     948:	60b9      	str	r1, [r7, #8]
     94a:	4613      	mov	r3, r2
     94c:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
     94e:	68fa      	ldr	r2, [r7, #12]
     950:	f240 0364 	movw	r3, #100	; 0x64
     954:	f2c2 0300 	movt	r3, #8192	; 0x2000
     958:	429a      	cmp	r2, r3
     95a:	d007      	beq.n	96c <global_init+0x2c>
     95c:	68fa      	ldr	r2, [r7, #12]
     95e:	f240 0324 	movw	r3, #36	; 0x24
     962:	f2c2 0300 	movt	r3, #8192	; 0x2000
     966:	429a      	cmp	r2, r3
     968:	d000      	beq.n	96c <global_init+0x2c>
     96a:	be00      	bkpt	0x0000

    if(this_uart == &g_mss_uart0)
     96c:	68fa      	ldr	r2, [r7, #12]
     96e:	f240 0364 	movw	r3, #100	; 0x64
     972:	f2c2 0300 	movt	r3, #8192	; 0x2000
     976:	429a      	cmp	r2, r3
     978:	d124      	bne.n	9c4 <global_init+0x84>
    {
        this_uart->hw_reg = UART0;
     97a:	68fb      	ldr	r3, [r7, #12]
     97c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     980:	601a      	str	r2, [r3, #0]
        this_uart->irqn = UART0_IRQn;
     982:	68fb      	ldr	r3, [r7, #12]
     984:	f04f 020a 	mov.w	r2, #10
     988:	711a      	strb	r2, [r3, #4]
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
     98a:	f248 0300 	movw	r3, #32768	; 0x8000
     98e:	f2c4 0303 	movt	r3, #16387	; 0x4003
     992:	f248 0200 	movw	r2, #32768	; 0x8000
     996:	f2c4 0203 	movt	r2, #16387	; 0x4003
     99a:	6c92      	ldr	r2, [r2, #72]	; 0x48
     99c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
     9a0:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
     9a2:	f04f 000a 	mov.w	r0, #10
     9a6:	f7ff fda9 	bl	4fc <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
     9aa:	f248 0300 	movw	r3, #32768	; 0x8000
     9ae:	f2c4 0303 	movt	r3, #16387	; 0x4003
     9b2:	f248 0200 	movw	r2, #32768	; 0x8000
     9b6:	f2c4 0203 	movt	r2, #16387	; 0x4003
     9ba:	6c92      	ldr	r2, [r2, #72]	; 0x48
     9bc:	f022 0280 	bic.w	r2, r2, #128	; 0x80
     9c0:	649a      	str	r2, [r3, #72]	; 0x48
     9c2:	e025      	b.n	a10 <global_init+0xd0>
    }
    else
    {
        this_uart->hw_reg = UART1;
     9c4:	68fa      	ldr	r2, [r7, #12]
     9c6:	f240 0300 	movw	r3, #0
     9ca:	f2c4 0301 	movt	r3, #16385	; 0x4001
     9ce:	6013      	str	r3, [r2, #0]
        this_uart->irqn = UART1_IRQn;
     9d0:	68fb      	ldr	r3, [r7, #12]
     9d2:	f04f 020b 	mov.w	r2, #11
     9d6:	711a      	strb	r2, [r3, #4]
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
     9d8:	f248 0300 	movw	r3, #32768	; 0x8000
     9dc:	f2c4 0303 	movt	r3, #16387	; 0x4003
     9e0:	f248 0200 	movw	r2, #32768	; 0x8000
     9e4:	f2c4 0203 	movt	r2, #16387	; 0x4003
     9e8:	6c92      	ldr	r2, [r2, #72]	; 0x48
     9ea:	f442 7280 	orr.w	r2, r2, #256	; 0x100
     9ee:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
     9f0:	f04f 000b 	mov.w	r0, #11
     9f4:	f7ff fd82 	bl	4fc <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
     9f8:	f248 0300 	movw	r3, #32768	; 0x8000
     9fc:	f2c4 0303 	movt	r3, #16387	; 0x4003
     a00:	f248 0200 	movw	r2, #32768	; 0x8000
     a04:	f2c4 0203 	movt	r2, #16387	; 0x4003
     a08:	6c92      	ldr	r2, [r2, #72]	; 0x48
     a0a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
     a0e:	649a      	str	r2, [r3, #72]	; 0x48
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
     a10:	68fb      	ldr	r3, [r7, #12]
     a12:	681b      	ldr	r3, [r3, #0]
     a14:	f04f 0200 	mov.w	r2, #0
     a18:	711a      	strb	r2, [r3, #4]

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
     a1a:	68fb      	ldr	r3, [r7, #12]
     a1c:	681b      	ldr	r3, [r3, #0]
     a1e:	f04f 0200 	mov.w	r2, #0
     a22:	721a      	strb	r2, [r3, #8]
    /* clear receiver FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_RX_FIFO);
     a24:	68fb      	ldr	r3, [r7, #12]
     a26:	681b      	ldr	r3, [r3, #0]
     a28:	f103 0308 	add.w	r3, r3, #8
     a2c:	4618      	mov	r0, r3
     a2e:	f04f 0101 	mov.w	r1, #1
     a32:	f7ff fd81 	bl	538 <set_bit_reg8>
    /* clear transmitter FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_TX_FIFO);
     a36:	68fb      	ldr	r3, [r7, #12]
     a38:	681b      	ldr	r3, [r3, #0]
     a3a:	f103 0308 	add.w	r3, r3, #8
     a3e:	4618      	mov	r0, r3
     a40:	f04f 0102 	mov.w	r1, #2
     a44:	f7ff fd78 	bl	538 <set_bit_reg8>

    /* set default READY mode : Mode 0*/
    /* enable RXRDYN and TXRDYN pins. The earlier FCR write to set the TX FIFO
     * trigger level inadvertently disabled the FCR_RXRDY_TXRDYN_EN bit. */
    set_bit_reg8(&this_uart->hw_reg->FCR,RXRDY_TXRDYN_EN);
     a48:	68fb      	ldr	r3, [r7, #12]
     a4a:	681b      	ldr	r3, [r3, #0]
     a4c:	f103 0308 	add.w	r3, r3, #8
     a50:	4618      	mov	r0, r3
     a52:	f04f 0100 	mov.w	r1, #0
     a56:	f7ff fd6f 	bl	538 <set_bit_reg8>

    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
     a5a:	68fb      	ldr	r3, [r7, #12]
     a5c:	681b      	ldr	r3, [r3, #0]
     a5e:	f103 0310 	add.w	r3, r3, #16
     a62:	4618      	mov	r0, r3
     a64:	f04f 0104 	mov.w	r1, #4
     a68:	f7ff fd86 	bl	578 <clear_bit_reg8>
    clear_bit_reg8(&this_uart->hw_reg->MCR,RLOOP);
     a6c:	68fb      	ldr	r3, [r7, #12]
     a6e:	681b      	ldr	r3, [r3, #0]
     a70:	f103 0310 	add.w	r3, r3, #16
     a74:	4618      	mov	r0, r3
     a76:	f04f 0105 	mov.w	r1, #5
     a7a:	f7ff fd7d 	bl	578 <clear_bit_reg8>

    /* set default TX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
     a7e:	68fb      	ldr	r3, [r7, #12]
     a80:	681b      	ldr	r3, [r3, #0]
     a82:	f103 0334 	add.w	r3, r3, #52	; 0x34
     a86:	4618      	mov	r0, r3
     a88:	f04f 0101 	mov.w	r1, #1
     a8c:	f7ff fd74 	bl	578 <clear_bit_reg8>
    /* set default RX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX);
     a90:	68fb      	ldr	r3, [r7, #12]
     a92:	681b      	ldr	r3, [r3, #0]
     a94:	f103 0334 	add.w	r3, r3, #52	; 0x34
     a98:	4618      	mov	r0, r3
     a9a:	f04f 0100 	mov.w	r1, #0
     a9e:	f7ff fd6b 	bl	578 <clear_bit_reg8>

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
     aa2:	68fb      	ldr	r3, [r7, #12]
     aa4:	681b      	ldr	r3, [r3, #0]
     aa6:	f103 0338 	add.w	r3, r3, #56	; 0x38
     aaa:	4618      	mov	r0, r3
     aac:	f04f 0101 	mov.w	r1, #1
     ab0:	f7ff fd62 	bl	578 <clear_bit_reg8>

    /* disable TX time gaurd */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG); 
     ab4:	68fb      	ldr	r3, [r7, #12]
     ab6:	681b      	ldr	r3, [r3, #0]
     ab8:	f103 0330 	add.w	r3, r3, #48	; 0x30
     abc:	4618      	mov	r0, r3
     abe:	f04f 0105 	mov.w	r1, #5
     ac2:	f7ff fd59 	bl	578 <clear_bit_reg8>

    /* set default RX timeout */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ERTO); 
     ac6:	68fb      	ldr	r3, [r7, #12]
     ac8:	681b      	ldr	r3, [r3, #0]
     aca:	f103 0330 	add.w	r3, r3, #48	; 0x30
     ace:	4618      	mov	r0, r3
     ad0:	f04f 0106 	mov.w	r1, #6
     ad4:	f7ff fd50 	bl	578 <clear_bit_reg8>

    /* disable fractional baud-rate */
    clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR); 
     ad8:	68fb      	ldr	r3, [r7, #12]
     ada:	681b      	ldr	r3, [r3, #0]
     adc:	f103 0330 	add.w	r3, r3, #48	; 0x30
     ae0:	4618      	mov	r0, r3
     ae2:	f04f 0107 	mov.w	r1, #7
     ae6:	f7ff fd47 	bl	578 <clear_bit_reg8>

    /* disable single wire mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
     aea:	68fb      	ldr	r3, [r7, #12]
     aec:	681b      	ldr	r3, [r3, #0]
     aee:	f103 0338 	add.w	r3, r3, #56	; 0x38
     af2:	4618      	mov	r0, r3
     af4:	f04f 0103 	mov.w	r1, #3
     af8:	f7ff fd3e 	bl	578 <clear_bit_reg8>

    /* set filter to minimum value */
    this_uart->hw_reg->GFR = 0u;
     afc:	68fb      	ldr	r3, [r7, #12]
     afe:	681b      	ldr	r3, [r3, #0]
     b00:	f04f 0200 	mov.w	r2, #0
     b04:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    /* set default TX time gaurd */
    this_uart->hw_reg->TTG = 0u;
     b08:	68fb      	ldr	r3, [r7, #12]
     b0a:	681b      	ldr	r3, [r3, #0]
     b0c:	f04f 0200 	mov.w	r2, #0
     b10:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* set default RX timeout */
    this_uart->hw_reg->RTO = 0u;
     b14:	68fb      	ldr	r3, [r7, #12]
     b16:	681b      	ldr	r3, [r3, #0]
     b18:	f04f 0200 	mov.w	r2, #0
     b1c:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    
    /* 
     * Configure baud rate divisors. This uses the frational baud rate divisor
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);
     b20:	68f8      	ldr	r0, [r7, #12]
     b22:	68b9      	ldr	r1, [r7, #8]
     b24:	f7ff fe40 	bl	7a8 <config_baud_divisors>

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
     b28:	68fb      	ldr	r3, [r7, #12]
     b2a:	681b      	ldr	r3, [r3, #0]
     b2c:	79fa      	ldrb	r2, [r7, #7]
     b2e:	731a      	strb	r2, [r3, #12]

    /* Instance setup */
    this_uart->baudrate = baud_rate;
     b30:	68fb      	ldr	r3, [r7, #12]
     b32:	68ba      	ldr	r2, [r7, #8]
     b34:	609a      	str	r2, [r3, #8]
    this_uart->lineconfig = line_config;
     b36:	68fb      	ldr	r3, [r7, #12]
     b38:	79fa      	ldrb	r2, [r7, #7]
     b3a:	731a      	strb	r2, [r3, #12]
    this_uart->tx_buff_size = TX_COMPLETE;
     b3c:	68fb      	ldr	r3, [r7, #12]
     b3e:	f04f 0200 	mov.w	r2, #0
     b42:	615a      	str	r2, [r3, #20]
    this_uart->tx_buffer = (const uint8_t *)0;
     b44:	68fb      	ldr	r3, [r7, #12]
     b46:	f04f 0200 	mov.w	r2, #0
     b4a:	611a      	str	r2, [r3, #16]
    this_uart->tx_idx = 0u;
     b4c:	68fb      	ldr	r3, [r7, #12]
     b4e:	f04f 0200 	mov.w	r2, #0
     b52:	619a      	str	r2, [r3, #24]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
     b54:	68fb      	ldr	r3, [r7, #12]
     b56:	f04f 0200 	mov.w	r2, #0
     b5a:	621a      	str	r2, [r3, #32]
    this_uart->tx_handler       = NULL_HANDLER;
     b5c:	68fb      	ldr	r3, [r7, #12]
     b5e:	f04f 0200 	mov.w	r2, #0
     b62:	625a      	str	r2, [r3, #36]	; 0x24
    this_uart->linests_handler  = NULL_HANDLER;
     b64:	68fb      	ldr	r3, [r7, #12]
     b66:	f04f 0200 	mov.w	r2, #0
     b6a:	61da      	str	r2, [r3, #28]
    this_uart->modemsts_handler = NULL_HANDLER;
     b6c:	68fb      	ldr	r3, [r7, #12]
     b6e:	f04f 0200 	mov.w	r2, #0
     b72:	629a      	str	r2, [r3, #40]	; 0x28
    this_uart->rto_handler      = NULL_HANDLER;    
     b74:	68fb      	ldr	r3, [r7, #12]
     b76:	f04f 0200 	mov.w	r2, #0
     b7a:	62da      	str	r2, [r3, #44]	; 0x2c
    this_uart->nack_handler     = NULL_HANDLER;   
     b7c:	68fb      	ldr	r3, [r7, #12]
     b7e:	f04f 0200 	mov.w	r2, #0
     b82:	631a      	str	r2, [r3, #48]	; 0x30
    this_uart->pid_pei_handler  = NULL_HANDLER;
     b84:	68fb      	ldr	r3, [r7, #12]
     b86:	f04f 0200 	mov.w	r2, #0
     b8a:	635a      	str	r2, [r3, #52]	; 0x34
    this_uart->break_handler    = NULL_HANDLER;    
     b8c:	68fb      	ldr	r3, [r7, #12]
     b8e:	f04f 0200 	mov.w	r2, #0
     b92:	639a      	str	r2, [r3, #56]	; 0x38
    this_uart->sync_handler     = NULL_HANDLER;   
     b94:	68fb      	ldr	r3, [r7, #12]
     b96:	f04f 0200 	mov.w	r2, #0
     b9a:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Initialize the sticky status */
    this_uart->status = 0u;
     b9c:	68fb      	ldr	r3, [r7, #12]
     b9e:	f04f 0200 	mov.w	r2, #0
     ba2:	735a      	strb	r2, [r3, #13]
}
     ba4:	f107 0710 	add.w	r7, r7, #16
     ba8:	46bd      	mov	sp, r7
     baa:	bd80      	pop	{r7, pc}

00000bac <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
     bac:	b580      	push	{r7, lr}
     bae:	b084      	sub	sp, #16
     bb0:	af00      	add	r7, sp, #0
     bb2:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
     bb4:	687a      	ldr	r2, [r7, #4]
     bb6:	f240 0364 	movw	r3, #100	; 0x64
     bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bbe:	429a      	cmp	r2, r3
     bc0:	d007      	beq.n	bd2 <MSS_UART_isr+0x26>
     bc2:	687a      	ldr	r2, [r7, #4]
     bc4:	f240 0324 	movw	r3, #36	; 0x24
     bc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bcc:	429a      	cmp	r2, r3
     bce:	d000      	beq.n	bd2 <MSS_UART_isr+0x26>
     bd0:	be00      	bkpt	0x0000

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
     bd2:	687a      	ldr	r2, [r7, #4]
     bd4:	f240 0364 	movw	r3, #100	; 0x64
     bd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bdc:	429a      	cmp	r2, r3
     bde:	d007      	beq.n	bf0 <MSS_UART_isr+0x44>
     be0:	687a      	ldr	r2, [r7, #4]
     be2:	f240 0324 	movw	r3, #36	; 0x24
     be6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     bea:	429a      	cmp	r2, r3
     bec:	f040 80ef 	bne.w	dce <MSS_UART_isr+0x222>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
     bf0:	687b      	ldr	r3, [r7, #4]
     bf2:	681b      	ldr	r3, [r3, #0]
     bf4:	7a1b      	ldrb	r3, [r3, #8]
     bf6:	b2db      	uxtb	r3, r3
     bf8:	f003 030f 	and.w	r3, r3, #15
     bfc:	73fb      	strb	r3, [r7, #15]

        switch (iirf)
     bfe:	7bfb      	ldrb	r3, [r7, #15]
     c00:	2b0c      	cmp	r3, #12
     c02:	f200 80d7 	bhi.w	db4 <MSS_UART_isr+0x208>
     c06:	a201      	add	r2, pc, #4	; (adr r2, c0c <MSS_UART_isr+0x60>)
     c08:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     c0c:	00000c41 	.word	0x00000c41
     c10:	00000db5 	.word	0x00000db5
     c14:	00000c5f 	.word	0x00000c5f
     c18:	00000cb9 	.word	0x00000cb9
     c1c:	00000c7d 	.word	0x00000c7d
     c20:	00000db5 	.word	0x00000db5
     c24:	00000c9b 	.word	0x00000c9b
     c28:	00000db5 	.word	0x00000db5
     c2c:	00000db5 	.word	0x00000db5
     c30:	00000db5 	.word	0x00000db5
     c34:	00000db5 	.word	0x00000db5
     c38:	00000db5 	.word	0x00000db5
     c3c:	00000c7d 	.word	0x00000c7d
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
     c40:	687b      	ldr	r3, [r7, #4]
     c42:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c44:	2b00      	cmp	r3, #0
     c46:	d100      	bne.n	c4a <MSS_UART_isr+0x9e>
     c48:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->modemsts_handler)
     c4a:	687b      	ldr	r3, [r7, #4]
     c4c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c4e:	2b00      	cmp	r3, #0
     c50:	f000 80b2 	beq.w	db8 <MSS_UART_isr+0x20c>
                {
                   (*(this_uart->modemsts_handler))(this_uart);
     c54:	687b      	ldr	r3, [r7, #4]
     c56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c58:	6878      	ldr	r0, [r7, #4]
     c5a:	4798      	blx	r3
                }
            }
            break;
     c5c:	e0b7      	b.n	dce <MSS_UART_isr+0x222>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
     c5e:	687b      	ldr	r3, [r7, #4]
     c60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     c62:	2b00      	cmp	r3, #0
     c64:	d100      	bne.n	c68 <MSS_UART_isr+0xbc>
     c66:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->tx_handler)
     c68:	687b      	ldr	r3, [r7, #4]
     c6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     c6c:	2b00      	cmp	r3, #0
     c6e:	f000 80a5 	beq.w	dbc <MSS_UART_isr+0x210>
                {
                    (*(this_uart->tx_handler))(this_uart);
     c72:	687b      	ldr	r3, [r7, #4]
     c74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     c76:	6878      	ldr	r0, [r7, #4]
     c78:	4798      	blx	r3
                }
            }
            break;
     c7a:	e0a8      	b.n	dce <MSS_UART_isr+0x222>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
     c7c:	687b      	ldr	r3, [r7, #4]
     c7e:	6a1b      	ldr	r3, [r3, #32]
     c80:	2b00      	cmp	r3, #0
     c82:	d100      	bne.n	c86 <MSS_UART_isr+0xda>
     c84:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->rx_handler)
     c86:	687b      	ldr	r3, [r7, #4]
     c88:	6a1b      	ldr	r3, [r3, #32]
     c8a:	2b00      	cmp	r3, #0
     c8c:	f000 8098 	beq.w	dc0 <MSS_UART_isr+0x214>
                {
                    (*(this_uart->rx_handler))(this_uart);
     c90:	687b      	ldr	r3, [r7, #4]
     c92:	6a1b      	ldr	r3, [r3, #32]
     c94:	6878      	ldr	r0, [r7, #4]
     c96:	4798      	blx	r3
                }
            }
            break;
     c98:	e099      	b.n	dce <MSS_UART_isr+0x222>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
     c9a:	687b      	ldr	r3, [r7, #4]
     c9c:	69db      	ldr	r3, [r3, #28]
     c9e:	2b00      	cmp	r3, #0
     ca0:	d100      	bne.n	ca4 <MSS_UART_isr+0xf8>
     ca2:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->linests_handler)
     ca4:	687b      	ldr	r3, [r7, #4]
     ca6:	69db      	ldr	r3, [r3, #28]
     ca8:	2b00      	cmp	r3, #0
     caa:	f000 808b 	beq.w	dc4 <MSS_UART_isr+0x218>
                {
                   (*(this_uart->linests_handler))(this_uart);
     cae:	687b      	ldr	r3, [r7, #4]
     cb0:	69db      	ldr	r3, [r3, #28]
     cb2:	6878      	ldr	r0, [r7, #4]
     cb4:	4798      	blx	r3
                }
            }
            break;
     cb6:	e08a      	b.n	dce <MSS_UART_isr+0x222>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
     cb8:	687b      	ldr	r3, [r7, #4]
     cba:	681b      	ldr	r3, [r3, #0]
     cbc:	f103 0328 	add.w	r3, r3, #40	; 0x28
     cc0:	4618      	mov	r0, r3
     cc2:	f04f 0100 	mov.w	r1, #0
     cc6:	f7ff fc77 	bl	5b8 <read_bit_reg8>
     cca:	4603      	mov	r3, r0
     ccc:	2b00      	cmp	r3, #0
     cce:	d00c      	beq.n	cea <MSS_UART_isr+0x13e>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
     cd0:	687b      	ldr	r3, [r7, #4]
     cd2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     cd4:	2b00      	cmp	r3, #0
     cd6:	d100      	bne.n	cda <MSS_UART_isr+0x12e>
     cd8:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->rto_handler)
     cda:	687b      	ldr	r3, [r7, #4]
     cdc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     cde:	2b00      	cmp	r3, #0
     ce0:	d003      	beq.n	cea <MSS_UART_isr+0x13e>
                    {
                        (*(this_uart->rto_handler))(this_uart);
     ce2:	687b      	ldr	r3, [r7, #4]
     ce4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     ce6:	6878      	ldr	r0, [r7, #4]
     ce8:	4798      	blx	r3
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
     cea:	687b      	ldr	r3, [r7, #4]
     cec:	681b      	ldr	r3, [r3, #0]
     cee:	f103 0328 	add.w	r3, r3, #40	; 0x28
     cf2:	4618      	mov	r0, r3
     cf4:	f04f 0101 	mov.w	r1, #1
     cf8:	f7ff fc5e 	bl	5b8 <read_bit_reg8>
     cfc:	4603      	mov	r3, r0
     cfe:	2b00      	cmp	r3, #0
     d00:	d00c      	beq.n	d1c <MSS_UART_isr+0x170>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
     d02:	687b      	ldr	r3, [r7, #4]
     d04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     d06:	2b00      	cmp	r3, #0
     d08:	d100      	bne.n	d0c <MSS_UART_isr+0x160>
     d0a:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->nack_handler)
     d0c:	687b      	ldr	r3, [r7, #4]
     d0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     d10:	2b00      	cmp	r3, #0
     d12:	d003      	beq.n	d1c <MSS_UART_isr+0x170>
                    {
                        (*(this_uart->nack_handler))(this_uart);
     d14:	687b      	ldr	r3, [r7, #4]
     d16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     d18:	6878      	ldr	r0, [r7, #4]
     d1a:	4798      	blx	r3
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
     d1c:	687b      	ldr	r3, [r7, #4]
     d1e:	681b      	ldr	r3, [r3, #0]
     d20:	f103 0328 	add.w	r3, r3, #40	; 0x28
     d24:	4618      	mov	r0, r3
     d26:	f04f 0102 	mov.w	r1, #2
     d2a:	f7ff fc45 	bl	5b8 <read_bit_reg8>
     d2e:	4603      	mov	r3, r0
     d30:	2b00      	cmp	r3, #0
     d32:	d00c      	beq.n	d4e <MSS_UART_isr+0x1a2>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
     d34:	687b      	ldr	r3, [r7, #4]
     d36:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     d38:	2b00      	cmp	r3, #0
     d3a:	d100      	bne.n	d3e <MSS_UART_isr+0x192>
     d3c:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
     d3e:	687b      	ldr	r3, [r7, #4]
     d40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     d42:	2b00      	cmp	r3, #0
     d44:	d003      	beq.n	d4e <MSS_UART_isr+0x1a2>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
     d46:	687b      	ldr	r3, [r7, #4]
     d48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     d4a:	6878      	ldr	r0, [r7, #4]
     d4c:	4798      	blx	r3
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
     d4e:	687b      	ldr	r3, [r7, #4]
     d50:	681b      	ldr	r3, [r3, #0]
     d52:	f103 0328 	add.w	r3, r3, #40	; 0x28
     d56:	4618      	mov	r0, r3
     d58:	f04f 0103 	mov.w	r1, #3
     d5c:	f7ff fc2c 	bl	5b8 <read_bit_reg8>
     d60:	4603      	mov	r3, r0
     d62:	2b00      	cmp	r3, #0
     d64:	d00c      	beq.n	d80 <MSS_UART_isr+0x1d4>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
     d66:	687b      	ldr	r3, [r7, #4]
     d68:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     d6a:	2b00      	cmp	r3, #0
     d6c:	d100      	bne.n	d70 <MSS_UART_isr+0x1c4>
     d6e:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->break_handler)
     d70:	687b      	ldr	r3, [r7, #4]
     d72:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     d74:	2b00      	cmp	r3, #0
     d76:	d003      	beq.n	d80 <MSS_UART_isr+0x1d4>
                    {
                        (*(this_uart->break_handler))(this_uart);
     d78:	687b      	ldr	r3, [r7, #4]
     d7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     d7c:	6878      	ldr	r0, [r7, #4]
     d7e:	4798      	blx	r3
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
     d80:	687b      	ldr	r3, [r7, #4]
     d82:	681b      	ldr	r3, [r3, #0]
     d84:	f103 0328 	add.w	r3, r3, #40	; 0x28
     d88:	4618      	mov	r0, r3
     d8a:	f04f 0104 	mov.w	r1, #4
     d8e:	f7ff fc13 	bl	5b8 <read_bit_reg8>
     d92:	4603      	mov	r3, r0
     d94:	2b00      	cmp	r3, #0
     d96:	d017      	beq.n	dc8 <MSS_UART_isr+0x21c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
     d98:	687b      	ldr	r3, [r7, #4]
     d9a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     d9c:	2b00      	cmp	r3, #0
     d9e:	d100      	bne.n	da2 <MSS_UART_isr+0x1f6>
     da0:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->sync_handler)
     da2:	687b      	ldr	r3, [r7, #4]
     da4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     da6:	2b00      	cmp	r3, #0
     da8:	d010      	beq.n	dcc <MSS_UART_isr+0x220>
                    {
                        (*(this_uart->sync_handler))(this_uart);
     daa:	687b      	ldr	r3, [r7, #4]
     dac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     dae:	6878      	ldr	r0, [r7, #4]
     db0:	4798      	blx	r3
                    }
                }
                break;
     db2:	e00c      	b.n	dce <MSS_UART_isr+0x222>
            }

            default:
            {
                ASSERT(INVALID_INTERRUPT);
     db4:	be00      	bkpt	0x0000
     db6:	e00a      	b.n	dce <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->modemsts_handler)
                {
                   (*(this_uart->modemsts_handler))(this_uart);
                }
            }
            break;
     db8:	bf00      	nop
     dba:	e008      	b.n	dce <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->tx_handler)
                {
                    (*(this_uart->tx_handler))(this_uart);
                }
            }
            break;
     dbc:	bf00      	nop
     dbe:	e006      	b.n	dce <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->rx_handler)
                {
                    (*(this_uart->rx_handler))(this_uart);
                }
            }
            break;
     dc0:	bf00      	nop
     dc2:	e004      	b.n	dce <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->linests_handler)
                {
                   (*(this_uart->linests_handler))(this_uart);
                }
            }
            break;
     dc4:	bf00      	nop
     dc6:	e002      	b.n	dce <MSS_UART_isr+0x222>
                    if(NULL_HANDLER != this_uart->sync_handler)
                    {
                        (*(this_uart->sync_handler))(this_uart);
                    }
                }
                break;
     dc8:	bf00      	nop
     dca:	e000      	b.n	dce <MSS_UART_isr+0x222>
     dcc:	bf00      	nop
                ASSERT(INVALID_INTERRUPT);
            }
            break;
        }
    }
}
     dce:	f107 0710 	add.w	r7, r7, #16
     dd2:	46bd      	mov	sp, r7
     dd4:	bd80      	pop	{r7, pc}
     dd6:	bf00      	nop

00000dd8 <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
     dd8:	b580      	push	{r7, lr}
     dda:	b086      	sub	sp, #24
     ddc:	af00      	add	r7, sp, #0
     dde:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
     de0:	687a      	ldr	r2, [r7, #4]
     de2:	f240 0364 	movw	r3, #100	; 0x64
     de6:	f2c2 0300 	movt	r3, #8192	; 0x2000
     dea:	429a      	cmp	r2, r3
     dec:	d007      	beq.n	dfe <default_tx_handler+0x26>
     dee:	687a      	ldr	r2, [r7, #4]
     df0:	f240 0324 	movw	r3, #36	; 0x24
     df4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     df8:	429a      	cmp	r2, r3
     dfa:	d000      	beq.n	dfe <default_tx_handler+0x26>
     dfc:	be00      	bkpt	0x0000
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
     dfe:	687b      	ldr	r3, [r7, #4]
     e00:	691b      	ldr	r3, [r3, #16]
     e02:	2b00      	cmp	r3, #0
     e04:	d100      	bne.n	e08 <default_tx_handler+0x30>
     e06:	be00      	bkpt	0x0000
    ASSERT(0u < this_uart->tx_buff_size);
     e08:	687b      	ldr	r3, [r7, #4]
     e0a:	695b      	ldr	r3, [r3, #20]
     e0c:	2b00      	cmp	r3, #0
     e0e:	d100      	bne.n	e12 <default_tx_handler+0x3a>
     e10:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
     e12:	687a      	ldr	r2, [r7, #4]
     e14:	f240 0364 	movw	r3, #100	; 0x64
     e18:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e1c:	429a      	cmp	r2, r3
     e1e:	d006      	beq.n	e2e <default_tx_handler+0x56>
     e20:	687a      	ldr	r2, [r7, #4]
     e22:	f240 0324 	movw	r3, #36	; 0x24
     e26:	f2c2 0300 	movt	r3, #8192	; 0x2000
     e2a:	429a      	cmp	r2, r3
     e2c:	d155      	bne.n	eda <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
     e2e:	687b      	ldr	r3, [r7, #4]
     e30:	691b      	ldr	r3, [r3, #16]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
     e32:	2b00      	cmp	r3, #0
     e34:	d051      	beq.n	eda <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
     e36:	687b      	ldr	r3, [r7, #4]
     e38:	695b      	ldr	r3, [r3, #20]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
     e3a:	2b00      	cmp	r3, #0
     e3c:	d04d      	beq.n	eda <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
     e3e:	687b      	ldr	r3, [r7, #4]
     e40:	681b      	ldr	r3, [r3, #0]
     e42:	7d1b      	ldrb	r3, [r3, #20]
     e44:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
     e46:	687b      	ldr	r3, [r7, #4]
     e48:	7b5a      	ldrb	r2, [r3, #13]
     e4a:	7afb      	ldrb	r3, [r7, #11]
     e4c:	ea42 0303 	orr.w	r3, r2, r3
     e50:	b2da      	uxtb	r2, r3
     e52:	687b      	ldr	r3, [r7, #4]
     e54:	735a      	strb	r2, [r3, #13]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
     e56:	7afb      	ldrb	r3, [r7, #11]
     e58:	f003 0320 	and.w	r3, r3, #32
     e5c:	2b00      	cmp	r3, #0
     e5e:	d029      	beq.n	eb4 <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
     e60:	f04f 0310 	mov.w	r3, #16
     e64:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
     e66:	687b      	ldr	r3, [r7, #4]
     e68:	695a      	ldr	r2, [r3, #20]
     e6a:	687b      	ldr	r3, [r7, #4]
     e6c:	699b      	ldr	r3, [r3, #24]
     e6e:	ebc3 0302 	rsb	r3, r3, r2
     e72:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if(tx_remain < TX_FIFO_SIZE)
     e74:	697b      	ldr	r3, [r7, #20]
     e76:	2b0f      	cmp	r3, #15
     e78:	d801      	bhi.n	e7e <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
     e7a:	697b      	ldr	r3, [r7, #20]
     e7c:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
     e7e:	f04f 0300 	mov.w	r3, #0
     e82:	60fb      	str	r3, [r7, #12]
     e84:	e012      	b.n	eac <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
     e86:	687b      	ldr	r3, [r7, #4]
     e88:	681b      	ldr	r3, [r3, #0]
     e8a:	687a      	ldr	r2, [r7, #4]
     e8c:	6911      	ldr	r1, [r2, #16]
     e8e:	687a      	ldr	r2, [r7, #4]
     e90:	6992      	ldr	r2, [r2, #24]
     e92:	440a      	add	r2, r1
     e94:	7812      	ldrb	r2, [r2, #0]
     e96:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
     e98:	687b      	ldr	r3, [r7, #4]
     e9a:	699b      	ldr	r3, [r3, #24]
     e9c:	f103 0201 	add.w	r2, r3, #1
     ea0:	687b      	ldr	r3, [r7, #4]
     ea2:	619a      	str	r2, [r3, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
     ea4:	68fb      	ldr	r3, [r7, #12]
     ea6:	f103 0301 	add.w	r3, r3, #1
     eaa:	60fb      	str	r3, [r7, #12]
     eac:	68fa      	ldr	r2, [r7, #12]
     eae:	693b      	ldr	r3, [r7, #16]
     eb0:	429a      	cmp	r2, r3
     eb2:	d3e8      	bcc.n	e86 <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
     eb4:	687b      	ldr	r3, [r7, #4]
     eb6:	699a      	ldr	r2, [r3, #24]
     eb8:	687b      	ldr	r3, [r7, #4]
     eba:	695b      	ldr	r3, [r3, #20]
     ebc:	429a      	cmp	r2, r3
     ebe:	d10c      	bne.n	eda <default_tx_handler+0x102>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
     ec0:	687b      	ldr	r3, [r7, #4]
     ec2:	f04f 0200 	mov.w	r2, #0
     ec6:	615a      	str	r2, [r3, #20]
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
     ec8:	687b      	ldr	r3, [r7, #4]
     eca:	681b      	ldr	r3, [r3, #0]
     ecc:	f103 0304 	add.w	r3, r3, #4
     ed0:	4618      	mov	r0, r3
     ed2:	f04f 0101 	mov.w	r1, #1
     ed6:	f7ff fb4f 	bl	578 <clear_bit_reg8>
        }
    }
}
     eda:	f107 0718 	add.w	r7, r7, #24
     ede:	46bd      	mov	sp, r7
     ee0:	bd80      	pop	{r7, pc}
     ee2:	bf00      	nop

00000ee4 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
     ee4:	b580      	push	{r7, lr}
     ee6:	b082      	sub	sp, #8
     ee8:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
     eea:	f000 fa0b 	bl	1304 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
     eee:	f64e 5300 	movw	r3, #60672	; 0xed00
     ef2:	f2ce 0300 	movt	r3, #57344	; 0xe000
     ef6:	f64e 5200 	movw	r2, #60672	; 0xed00
     efa:	f2ce 0200 	movt	r2, #57344	; 0xe000
     efe:	6952      	ldr	r2, [r2, #20]
     f00:	f442 7200 	orr.w	r2, r2, #512	; 0x200
     f04:	615a      	str	r2, [r3, #20]
    
    /*--------------------------------------------------------------------------
     * MDDR configuration
     */
#if MSS_SYS_MDDR_CONFIG_BY_CORTEX
    if(0u == SYSREG->DDR_CR)
     f06:	f248 0300 	movw	r3, #32768	; 0x8000
     f0a:	f2c4 0303 	movt	r3, #16387	; 0x4003
     f0e:	689b      	ldr	r3, [r3, #8]
     f10:	2b00      	cmp	r3, #0
     f12:	d10b      	bne.n	f2c <SystemInit+0x48>
         * to address 0x00000000. If MDDR is remapped to 0x00000000 then we are
         * probably executing this code from MDDR in a debugging session and
         * attempting to reconfigure the MDDR memory controller will cause the
         * Cortex-M3 to crash.
         */
        config_ddr_subsys(&g_m2s_mddr_subsys_config, &g_m2s_mddr_addr->core);
     f14:	f241 33d8 	movw	r3, #5080	; 0x13d8
     f18:	f2c0 0300 	movt	r3, #0
     f1c:	681b      	ldr	r3, [r3, #0]
     f1e:	f241 30dc 	movw	r0, #5084	; 0x13dc
     f22:	f2c0 0000 	movt	r0, #0
     f26:	4619      	mov	r1, r3
     f28:	f000 f94c 	bl	11c4 <config_ddr_subsys>
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
     f2c:	f7ff fa30 	bl	390 <mscc_post_hw_cfg_init>
     * do this here because this signal is only deasserted by the System
     * Controller on a power-on reset. Other types of reset such as a watchdog
     * reset would result in the FPGA fabric being held in reset and getting
     * stuck waiting for the CoreSF2Config INIT_DONE to become asserted.
     */
    SYSREG->SOFT_RST_CR &= ~SYSREG_FPGA_SOFTRESET_MASK;
     f30:	f248 0300 	movw	r3, #32768	; 0x8000
     f34:	f2c4 0303 	movt	r3, #16387	; 0x4003
     f38:	f248 0200 	movw	r2, #32768	; 0x8000
     f3c:	f2c4 0203 	movt	r2, #16387	; 0x4003
     f40:	6c92      	ldr	r2, [r2, #72]	; 0x48
     f42:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
     f46:	649a      	str	r2, [r3, #72]	; 0x48

    /*
     * Signal to CoreSF2Reset that peripheral configuration registers have been
     * written.
     */
    CORE_SF2_CFG->CONFIG_DONE |= (CONFIG_1_DONE | CONFIG_2_DONE);
     f48:	f242 0300 	movw	r3, #8192	; 0x2000
     f4c:	f2c4 0302 	movt	r3, #16386	; 0x4002
     f50:	f242 0200 	movw	r2, #8192	; 0x2000
     f54:	f2c4 0202 	movt	r2, #16386	; 0x4002
     f58:	6812      	ldr	r2, [r2, #0]
     f5a:	f042 0203 	orr.w	r2, r2, #3
     f5e:	601a      	str	r2, [r3, #0]
     
    /* Wait for INIT_DONE from CoreSF2Reset. */
    do
    {
        init_done = CORE_SF2_CFG->INIT_DONE & INIT_DONE_MASK;
     f60:	f242 0300 	movw	r3, #8192	; 0x2000
     f64:	f2c4 0302 	movt	r3, #16386	; 0x4002
     f68:	685b      	ldr	r3, [r3, #4]
     f6a:	f003 0301 	and.w	r3, r3, #1
     f6e:	607b      	str	r3, [r7, #4]
    } while (0u == init_done);
     f70:	687b      	ldr	r3, [r7, #4]
     f72:	2b00      	cmp	r3, #0
     f74:	d0f4      	beq.n	f60 <SystemInit+0x7c>
#endif
}
     f76:	f107 0708 	add.w	r7, r7, #8
     f7a:	46bd      	mov	sp, r7
     f7c:	bd80      	pop	{r7, pc}
     f7e:	bf00      	nop

00000f80 <SystemCoreClockUpdate>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
     f80:	b580      	push	{r7, lr}
     f82:	b088      	sub	sp, #32
     f84:	af00      	add	r7, sp, #0
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
     f86:	f248 0300 	movw	r3, #32768	; 0x8000
     f8a:	f2c4 0303 	movt	r3, #16387	; 0x4003
     f8e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
     f92:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
     f96:	60fb      	str	r3, [r7, #12]
    
    if(0u == controller_pll_init)
     f98:	68fb      	ldr	r3, [r7, #12]
     f9a:	2b00      	cmp	r3, #0
     f9c:	f040 808b 	bne.w	10b6 <PROCESS_STACK_SIZE+0xb6>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;
        
        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
     fa0:	f248 0300 	movw	r3, #32768	; 0x8000
     fa4:	f2c4 0303 	movt	r3, #16387	; 0x4003
     fa8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
     fac:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
     fb0:	617b      	str	r3, [r7, #20]
        if(0u == global_mux_sel)
     fb2:	697b      	ldr	r3, [r7, #20]
     fb4:	2b00      	cmp	r3, #0
     fb6:	d13f      	bne.n	1038 <PROCESS_STACK_SIZE+0x38>
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
     fb8:	f240 0304 	movw	r3, #4
     fbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fc0:	f24e 1200 	movw	r2, #57600	; 0xe100
     fc4:	f2c0 52f5 	movt	r2, #1525	; 0x5f5
     fc8:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
     fca:	f240 0308 	movw	r3, #8
     fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fd2:	f24e 1200 	movw	r2, #57600	; 0xe100
     fd6:	f2c0 52f5 	movt	r2, #1525	; 0x5f5
     fda:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
     fdc:	f240 030c 	movw	r3, #12
     fe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     fe4:	f24e 1200 	movw	r2, #57600	; 0xe100
     fe8:	f2c0 52f5 	movt	r2, #1525	; 0x5f5
     fec:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
     fee:	f240 0310 	movw	r3, #16
     ff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
     ff6:	f647 0240 	movw	r2, #30784	; 0x7840
     ffa:	f2c0 127d 	movt	r2, #381	; 0x17d
     ffe:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
    1000:	f240 0314 	movw	r3, #20
    1004:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1008:	f24e 1200 	movw	r2, #57600	; 0xe100
    100c:	f2c0 52f5 	movt	r2, #1525	; 0x5f5
    1010:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
    1012:	f240 0318 	movw	r3, #24
    1016:	f2c2 0300 	movt	r3, #8192	; 0x2000
    101a:	f24e 1200 	movw	r2, #57600	; 0xe100
    101e:	f2c0 52f5 	movt	r2, #1525	; 0x5f5
    1022:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
    1024:	f240 031c 	movw	r3, #28
    1028:	f2c2 0300 	movt	r3, #8192	; 0x2000
    102c:	f24c 2200 	movw	r2, #49664	; 0xc200
    1030:	f6c0 32eb 	movt	r2, #3051	; 0xbeb
    1034:	601a      	str	r2, [r3, #0]
                break;
                
                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
    1036:	e045      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
    1038:	f241 33d0 	movw	r3, #5072	; 0x13d0
    103c:	f2c0 0300 	movt	r3, #0
    1040:	f107 0204 	add.w	r2, r7, #4
    1044:	e893 0003 	ldmia.w	r3, {r0, r1}
    1048:	e882 0003 	stmia.w	r2, {r0, r1}
            
            uint32_t standby_sel;
            uint8_t clock_source;
            
            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
    104c:	f248 0300 	movw	r3, #32768	; 0x8000
    1050:	f2c4 0303 	movt	r3, #16387	; 0x4003
    1054:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    1058:	ea4f 1393 	mov.w	r3, r3, lsr #6
    105c:	f003 0307 	and.w	r3, r3, #7
    1060:	61bb      	str	r3, [r7, #24]
            clock_source = standby_clock_lut[standby_sel];
    1062:	69bb      	ldr	r3, [r7, #24]
    1064:	f107 0220 	add.w	r2, r7, #32
    1068:	4413      	add	r3, r2
    106a:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
    106e:	77fb      	strb	r3, [r7, #31]
            switch(clock_source)
    1070:	7ffb      	ldrb	r3, [r7, #31]
    1072:	2b01      	cmp	r3, #1
    1074:	d00b      	beq.n	108e <PROCESS_STACK_SIZE+0x8e>
    1076:	2b02      	cmp	r3, #2
    1078:	d00e      	beq.n	1098 <PROCESS_STACK_SIZE+0x98>
    107a:	2b00      	cmp	r3, #0
    107c:	d114      	bne.n	10a8 <PROCESS_STACK_SIZE+0xa8>
            {
                case RCOSC_25_50MHZ_CLK_SRC:
                    clk_src = get_rcosc_25_50mhz_frequency();
    107e:	f000 f825 	bl	10cc <get_rcosc_25_50mhz_frequency>
    1082:	4603      	mov	r3, r0
    1084:	613b      	str	r3, [r7, #16]
                    set_clock_frequency_globals(clk_src);
    1086:	6938      	ldr	r0, [r7, #16]
    1088:	f000 f842 	bl	1110 <set_clock_frequency_globals>
                break;
    108c:	e01a      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
                
                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
    108e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    1092:	f000 f83d 	bl	1110 <set_clock_frequency_globals>
                break;
    1096:	e015      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
                
                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
    1098:	f244 2040 	movw	r0, #16960	; 0x4240
    109c:	f2c0 000f 	movt	r0, #15
    10a0:	f000 f836 	bl	1110 <set_clock_frequency_globals>
                break;
    10a4:	bf00      	nop
    10a6:	e00d      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
                
                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
    10a8:	f244 2040 	movw	r0, #16960	; 0x4240
    10ac:	f2c0 000f 	movt	r0, #15
    10b0:	f000 f82e 	bl	1110 <set_clock_frequency_globals>
    10b4:	e006      	b.n	10c4 <PROCESS_STACK_SIZE+0xc4>
        }
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
    10b6:	f000 f809 	bl	10cc <get_rcosc_25_50mhz_frequency>
    10ba:	4603      	mov	r3, r0
    10bc:	613b      	str	r3, [r7, #16]
        set_clock_frequency_globals(clk_src);
    10be:	6938      	ldr	r0, [r7, #16]
    10c0:	f000 f826 	bl	1110 <set_clock_frequency_globals>
    }
}
    10c4:	f107 0720 	add.w	r7, r7, #32
    10c8:	46bd      	mov	sp, r7
    10ca:	bd80      	pop	{r7, pc}

000010cc <get_rcosc_25_50mhz_frequency>:

/***************************************************************************//**
 * Find out frequency generated by the 25_50mhz RC osciallator.
 */
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
    10cc:	b480      	push	{r7}
    10ce:	b083      	sub	sp, #12
    10d0:	af00      	add	r7, sp, #0
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;
    
    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
    10d2:	f248 0300 	movw	r3, #32768	; 0x8000
    10d6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    10da:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
    10de:	f003 0304 	and.w	r3, r3, #4
    10e2:	603b      	str	r3, [r7, #0]
    if(0u == rcosc_div2)
    10e4:	683b      	ldr	r3, [r7, #0]
    10e6:	2b00      	cmp	r3, #0
    10e8:	d105      	bne.n	10f6 <get_rcosc_25_50mhz_frequency+0x2a>
    {
        /* 25_50mhz oscillator is configured for 25 MHz operations. */
        rcosc_frequency = FREQ_25MHZ;
    10ea:	f647 0340 	movw	r3, #30784	; 0x7840
    10ee:	f2c0 137d 	movt	r3, #381	; 0x17d
    10f2:	607b      	str	r3, [r7, #4]
    10f4:	e004      	b.n	1100 <get_rcosc_25_50mhz_frequency+0x34>
    }
    else
    {
        /* 25_50mhz oscillator is configured for 50 MHz operations. */
        rcosc_frequency = FREQ_50MHZ;
    10f6:	f24f 0380 	movw	r3, #61568	; 0xf080
    10fa:	f2c0 23fa 	movt	r3, #762	; 0x2fa
    10fe:	607b      	str	r3, [r7, #4]
    }
    
    return rcosc_frequency;
    1100:	687b      	ldr	r3, [r7, #4]
}
    1102:	4618      	mov	r0, r3
    1104:	f107 070c 	add.w	r7, r7, #12
    1108:	46bd      	mov	sp, r7
    110a:	bc80      	pop	{r7}
    110c:	4770      	bx	lr
    110e:	bf00      	nop

00001110 <set_clock_frequency_globals>:
        - g_FrequencyFIC0
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    1110:	b480      	push	{r7}
    1112:	b083      	sub	sp, #12
    1114:	af00      	add	r7, sp, #0
    1116:	6078      	str	r0, [r7, #4]
    SystemCoreClock = standby_clk;
    1118:	f240 0304 	movw	r3, #4
    111c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1120:	687a      	ldr	r2, [r7, #4]
    1122:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
    1124:	f240 0308 	movw	r3, #8
    1128:	f2c2 0300 	movt	r3, #8192	; 0x2000
    112c:	687a      	ldr	r2, [r7, #4]
    112e:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = standby_clk;
    1130:	f240 030c 	movw	r3, #12
    1134:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1138:	687a      	ldr	r2, [r7, #4]
    113a:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    113c:	f240 0310 	movw	r3, #16
    1140:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1144:	f647 0240 	movw	r2, #30784	; 0x7840
    1148:	f2c0 127d 	movt	r2, #381	; 0x17d
    114c:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC0 = standby_clk;
    114e:	f240 0314 	movw	r3, #20
    1152:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1156:	687a      	ldr	r2, [r7, #4]
    1158:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC1 = standby_clk;
    115a:	f240 0318 	movw	r3, #24
    115e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1162:	687a      	ldr	r2, [r7, #4]
    1164:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC64 = standby_clk;
    1166:	f240 031c 	movw	r3, #28
    116a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    116e:	687a      	ldr	r2, [r7, #4]
    1170:	601a      	str	r2, [r3, #0]
}
    1172:	f107 070c 	add.w	r7, r7, #12
    1176:	46bd      	mov	sp, r7
    1178:	bc80      	pop	{r7}
    117a:	4770      	bx	lr

0000117c <copy_cfg16_to_regs>:
(
    volatile uint32_t * p_regs,
    const uint16_t * p_cfg,
    uint32_t nb_16bit_words
)
{
    117c:	b480      	push	{r7}
    117e:	b087      	sub	sp, #28
    1180:	af00      	add	r7, sp, #0
    1182:	60f8      	str	r0, [r7, #12]
    1184:	60b9      	str	r1, [r7, #8]
    1186:	607a      	str	r2, [r7, #4]
    uint32_t inc;
    
    for(inc = 0u; inc < nb_16bit_words; ++inc)
    1188:	f04f 0300 	mov.w	r3, #0
    118c:	617b      	str	r3, [r7, #20]
    118e:	e00f      	b.n	11b0 <copy_cfg16_to_regs+0x34>
    {
        p_regs[inc] = p_cfg[inc];
    1190:	697b      	ldr	r3, [r7, #20]
    1192:	ea4f 0283 	mov.w	r2, r3, lsl #2
    1196:	68fb      	ldr	r3, [r7, #12]
    1198:	4413      	add	r3, r2
    119a:	697a      	ldr	r2, [r7, #20]
    119c:	ea4f 0142 	mov.w	r1, r2, lsl #1
    11a0:	68ba      	ldr	r2, [r7, #8]
    11a2:	440a      	add	r2, r1
    11a4:	8812      	ldrh	r2, [r2, #0]
    11a6:	601a      	str	r2, [r3, #0]
    uint32_t nb_16bit_words
)
{
    uint32_t inc;
    
    for(inc = 0u; inc < nb_16bit_words; ++inc)
    11a8:	697b      	ldr	r3, [r7, #20]
    11aa:	f103 0301 	add.w	r3, r3, #1
    11ae:	617b      	str	r3, [r7, #20]
    11b0:	697a      	ldr	r2, [r7, #20]
    11b2:	687b      	ldr	r3, [r7, #4]
    11b4:	429a      	cmp	r2, r3
    11b6:	d3eb      	bcc.n	1190 <copy_cfg16_to_regs+0x14>
    {
        p_regs[inc] = p_cfg[inc];
    }
}
    11b8:	f107 071c 	add.w	r7, r7, #28
    11bc:	46bd      	mov	sp, r7
    11be:	bc80      	pop	{r7}
    11c0:	4770      	bx	lr
    11c2:	bf00      	nop

000011c4 <config_ddr_subsys>:
static void config_ddr_subsys
(
    const ddr_subsys_cfg_t * p_ddr_subsys_cfg,
    DDRCore_TypeDef * p_ddr_subsys_regs
)
{
    11c4:	b580      	push	{r7, lr}
    11c6:	b084      	sub	sp, #16
    11c8:	af00      	add	r7, sp, #0
    11ca:	6078      	str	r0, [r7, #4]
    11cc:	6039      	str	r1, [r7, #0]
    const uint16_t * p_cfg;
    
    /*--------------------------------------------------------------------------
     * Configure DDR controller part of the MDDR subsystem.
     */
    p_cfg = &p_ddr_subsys_cfg->ddrc.DYN_SOFT_RESET_CR;
    11ce:	687b      	ldr	r3, [r7, #4]
    11d0:	60fb      	str	r3, [r7, #12]
    p_regs = &p_ddr_subsys_regs->ddrc.DYN_SOFT_RESET_CR;
    11d2:	683b      	ldr	r3, [r7, #0]
    11d4:	60bb      	str	r3, [r7, #8]

    copy_cfg16_to_regs(p_regs, p_cfg, NB_OF_DDRC_REGS_TO_CONFIG);
    11d6:	68b8      	ldr	r0, [r7, #8]
    11d8:	68f9      	ldr	r1, [r7, #12]
    11da:	f04f 0239 	mov.w	r2, #57	; 0x39
    11de:	f7ff ffcd 	bl	117c <copy_cfg16_to_regs>
    
    /*--------------------------------------------------------------------------
     * Configure DDR PHY.
     */
    p_cfg = &p_ddr_subsys_cfg->phy.LOOPBACK_TEST_CR;
    11e2:	687b      	ldr	r3, [r7, #4]
    11e4:	f103 0372 	add.w	r3, r3, #114	; 0x72
    11e8:	60fb      	str	r3, [r7, #12]
    p_regs = &p_ddr_subsys_regs->phy.LOOPBACK_TEST_CR;
    11ea:	683b      	ldr	r3, [r7, #0]
    11ec:	f503 7307 	add.w	r3, r3, #540	; 0x21c
    11f0:	60bb      	str	r3, [r7, #8]

    copy_cfg16_to_regs(p_regs, p_cfg, NB_OF_DDR_PHY_REGS_TO_CONFIG);
    11f2:	68b8      	ldr	r0, [r7, #8]
    11f4:	68f9      	ldr	r1, [r7, #12]
    11f6:	f04f 0241 	mov.w	r2, #65	; 0x41
    11fa:	f7ff ffbf 	bl	117c <copy_cfg16_to_regs>
    
    /*--------------------------------------------------------------------------
     * Configure DDR FIC.
     */
    p_ddr_subsys_regs->fic.NB_ADDR_CR = p_ddr_subsys_cfg->fic.NB_ADDR_CR;
    11fe:	687b      	ldr	r3, [r7, #4]
    1200:	f8b3 30f4 	ldrh.w	r3, [r3, #244]	; 0xf4
    1204:	461a      	mov	r2, r3
    1206:	683b      	ldr	r3, [r7, #0]
    1208:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    p_ddr_subsys_regs->fic.NBRWB_SIZE_CR = p_ddr_subsys_cfg->fic.NBRWB_SIZE_CR;
    120c:	687b      	ldr	r3, [r7, #4]
    120e:	f8b3 30f6 	ldrh.w	r3, [r3, #246]	; 0xf6
    1212:	461a      	mov	r2, r3
    1214:	683b      	ldr	r3, [r7, #0]
    1216:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
    p_ddr_subsys_regs->fic.WB_TIMEOUT_CR = p_ddr_subsys_cfg->fic.WB_TIMEOUT_CR;
    121a:	687b      	ldr	r3, [r7, #4]
    121c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
    1220:	461a      	mov	r2, r3
    1222:	683b      	ldr	r3, [r7, #0]
    1224:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
    p_ddr_subsys_regs->fic.HPD_SW_RW_EN_CR = p_ddr_subsys_cfg->fic.HPD_SW_RW_EN_CR;
    1228:	687b      	ldr	r3, [r7, #4]
    122a:	f8b3 30fa 	ldrh.w	r3, [r3, #250]	; 0xfa
    122e:	461a      	mov	r2, r3
    1230:	683b      	ldr	r3, [r7, #0]
    1232:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
    p_ddr_subsys_regs->fic.HPD_SW_RW_INVAL_CR = p_ddr_subsys_cfg->fic.HPD_SW_RW_INVAL_CR;
    1236:	687b      	ldr	r3, [r7, #4]
    1238:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
    123c:	461a      	mov	r2, r3
    123e:	683b      	ldr	r3, [r7, #0]
    1240:	f8c3 2410 	str.w	r2, [r3, #1040]	; 0x410
    p_ddr_subsys_regs->fic.SW_WR_ERCLR_CR = p_ddr_subsys_cfg->fic.SW_WR_ERCLR_CR;
    1244:	687b      	ldr	r3, [r7, #4]
    1246:	f8b3 30fe 	ldrh.w	r3, [r3, #254]	; 0xfe
    124a:	461a      	mov	r2, r3
    124c:	683b      	ldr	r3, [r7, #0]
    124e:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
    p_ddr_subsys_regs->fic.ERR_INT_ENABLE_CR = p_ddr_subsys_cfg->fic.ERR_INT_ENABLE_CR;
    1252:	687b      	ldr	r3, [r7, #4]
    1254:	f8b3 3100 	ldrh.w	r3, [r3, #256]	; 0x100
    1258:	461a      	mov	r2, r3
    125a:	683b      	ldr	r3, [r7, #0]
    125c:	f8c3 2418 	str.w	r2, [r3, #1048]	; 0x418
    p_ddr_subsys_regs->fic.NUM_AHB_MASTERS_CR = p_ddr_subsys_cfg->fic.NUM_AHB_MASTERS_CR;
    1260:	687b      	ldr	r3, [r7, #4]
    1262:	f8b3 3102 	ldrh.w	r3, [r3, #258]	; 0x102
    1266:	461a      	mov	r2, r3
    1268:	683b      	ldr	r3, [r7, #0]
    126a:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
    p_ddr_subsys_regs->fic.LOCK_TIMEOUTVAL_CR[0] = p_ddr_subsys_cfg->fic.LOCK_TIMEOUTVAL_1_CR;
    126e:	687b      	ldr	r3, [r7, #4]
    1270:	f8b3 3104 	ldrh.w	r3, [r3, #260]	; 0x104
    1274:	461a      	mov	r2, r3
    1276:	683b      	ldr	r3, [r7, #0]
    1278:	f8c3 2440 	str.w	r2, [r3, #1088]	; 0x440
    p_ddr_subsys_regs->fic.LOCK_TIMEOUTVAL_CR[1] = p_ddr_subsys_cfg->fic.LOCK_TIMEOUTVAL_2_CR;
    127c:	687b      	ldr	r3, [r7, #4]
    127e:	f8b3 3106 	ldrh.w	r3, [r3, #262]	; 0x106
    1282:	461a      	mov	r2, r3
    1284:	683b      	ldr	r3, [r7, #0]
    1286:	f8c3 2444 	str.w	r2, [r3, #1092]	; 0x444
    p_ddr_subsys_regs->fic.LOCK_TIMEOUT_EN_CR = p_ddr_subsys_cfg->fic.LOCK_TIMEOUT_EN_CR;
    128a:	687b      	ldr	r3, [r7, #4]
    128c:	f8b3 3108 	ldrh.w	r3, [r3, #264]	; 0x108
    1290:	461a      	mov	r2, r3
    1292:	683b      	ldr	r3, [r7, #0]
    1294:	f8c3 2448 	str.w	r2, [r3, #1096]	; 0x448

    /*--------------------------------------------------------------------------
     * Enable DDR.
     */
    p_ddr_subsys_regs->ddrc.DYN_SOFT_RESET_CR = 0x01u;
    1298:	683b      	ldr	r3, [r7, #0]
    129a:	f04f 0201 	mov.w	r2, #1
    129e:	601a      	str	r2, [r3, #0]
    
    while(0x0000u == p_ddr_subsys_regs->ddrc.DDRC_SR)
    12a0:	683b      	ldr	r3, [r7, #0]
    12a2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
    12a6:	2b00      	cmp	r3, #0
    12a8:	d0fa      	beq.n	12a0 <config_ddr_subsys+0xdc>
    {
        ;
    }        
}
    12aa:	f107 0710 	add.w	r7, r7, #16
    12ae:	46bd      	mov	sp, r7
    12b0:	bd80      	pop	{r7, pc}
    12b2:	bf00      	nop

000012b4 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
    12b4:	b480      	push	{r7}
    12b6:	b083      	sub	sp, #12
    12b8:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;
    
    device_version = SYSREG->DEVICE_VERSION;
    12ba:	f248 0300 	movw	r3, #32768	; 0x8000
    12be:	f2c4 0303 	movt	r3, #16387	; 0x4003
    12c2:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
    12c6:	607b      	str	r3, [r7, #4]
    switch(device_version)
    12c8:	687a      	ldr	r2, [r7, #4]
    12ca:	f64f 0302 	movw	r3, #63490	; 0xf802
    12ce:	429a      	cmp	r2, r3
    12d0:	d006      	beq.n	12e0 <get_silicon_revision+0x2c>
    12d2:	f64f 0302 	movw	r3, #63490	; 0xf802
    12d6:	f2c0 0301 	movt	r3, #1
    12da:	429a      	cmp	r2, r3
    12dc:	d004      	beq.n	12e8 <get_silicon_revision+0x34>
    12de:	e007      	b.n	12f0 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
    12e0:	f04f 0301 	mov.w	r3, #1
    12e4:	603b      	str	r3, [r7, #0]
            break;
    12e6:	e006      	b.n	12f6 <get_silicon_revision+0x42>
            
        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
    12e8:	f04f 0302 	mov.w	r3, #2
    12ec:	603b      	str	r3, [r7, #0]
            break;
    12ee:	e002      	b.n	12f6 <get_silicon_revision+0x42>
            
        default:
            silicon_revision = UNKNOWN_SILICON_REV;
    12f0:	f04f 0300 	mov.w	r3, #0
    12f4:	603b      	str	r3, [r7, #0]
            break;
    }
    
    return silicon_revision;
    12f6:	683b      	ldr	r3, [r7, #0]
}
    12f8:	4618      	mov	r0, r3
    12fa:	f107 070c 	add.w	r7, r7, #12
    12fe:	46bd      	mov	sp, r7
    1300:	bc80      	pop	{r7}
    1302:	4770      	bx	lr

00001304 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
    1304:	b580      	push	{r7, lr}
    1306:	b082      	sub	sp, #8
    1308:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    
    silicon_revision = get_silicon_revision();
    130a:	f7ff ffd3 	bl	12b4 <get_silicon_revision>
    130e:	4603      	mov	r3, r0
    1310:	607b      	str	r3, [r7, #4]
    
    switch(silicon_revision)
    1312:	687b      	ldr	r3, [r7, #4]
    1314:	2b01      	cmp	r3, #1
    1316:	d101      	bne.n	131c <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
    1318:	f000 f804 	bl	1324 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
    131c:	f107 0708 	add.w	r7, r7, #8
    1320:	46bd      	mov	sp, r7
    1322:	bd80      	pop	{r7, pc}

00001324 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
    1324:	b480      	push	{r7}
    1326:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
    1328:	f248 0300 	movw	r3, #32768	; 0x8000
    132c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    1330:	f248 0200 	movw	r2, #32768	; 0x8000
    1334:	f2c4 0203 	movt	r2, #16387	; 0x4003
    1338:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
    133c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    1340:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    
    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
    1344:	f248 0300 	movw	r3, #32768	; 0x8000
    1348:	f2c4 0303 	movt	r3, #16387	; 0x4003
    134c:	f248 0200 	movw	r2, #32768	; 0x8000
    1350:	f2c4 0203 	movt	r2, #16387	; 0x4003
    1354:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
    1358:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
    135c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
    1360:	46bd      	mov	sp, r7
    1362:	bc80      	pop	{r7}
    1364:	4770      	bx	lr
    1366:	bf00      	nop

00001368 <__libc_init_array>:
    1368:	b570      	push	{r4, r5, r6, lr}
    136a:	f241 5600 	movw	r6, #5376	; 0x1500
    136e:	f241 5500 	movw	r5, #5376	; 0x1500
    1372:	f2c0 0600 	movt	r6, #0
    1376:	f2c0 0500 	movt	r5, #0
    137a:	1b76      	subs	r6, r6, r5
    137c:	10b6      	asrs	r6, r6, #2
    137e:	d006      	beq.n	138e <__libc_init_array+0x26>
    1380:	2400      	movs	r4, #0
    1382:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    1386:	3401      	adds	r4, #1
    1388:	4798      	blx	r3
    138a:	42a6      	cmp	r6, r4
    138c:	d8f9      	bhi.n	1382 <__libc_init_array+0x1a>
    138e:	f241 5500 	movw	r5, #5376	; 0x1500
    1392:	f241 5604 	movw	r6, #5380	; 0x1504
    1396:	f2c0 0500 	movt	r5, #0
    139a:	f2c0 0600 	movt	r6, #0
    139e:	1b76      	subs	r6, r6, r5
    13a0:	f000 f8a2 	bl	14e8 <_init>
    13a4:	10b6      	asrs	r6, r6, #2
    13a6:	d006      	beq.n	13b6 <__libc_init_array+0x4e>
    13a8:	2400      	movs	r4, #0
    13aa:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    13ae:	3401      	adds	r4, #1
    13b0:	4798      	blx	r3
    13b2:	42a6      	cmp	r6, r4
    13b4:	d8f9      	bhi.n	13aa <__libc_init_array+0x42>
    13b6:	bd70      	pop	{r4, r5, r6, pc}
    13b8:	72617473 	.word	0x72617473
    13bc:	00212074 	.word	0x00212074
    13c0:	00000000 	.word	0x00000000
    13c4:	20646e65 	.word	0x20646e65
    13c8:	00000021 	.word	0x00000021
    13cc:	00000000 	.word	0x00000000

000013d0 <C.19.3551>:
    13d0:	01000100 03030202                       ........

000013d8 <g_m2s_mddr_addr>:
    13d8:	40020800                                ...@

000013dc <g_m2s_mddr_subsys_config>:
    13dc:	00000000 02901188 00000002 09990001     ................
    13ec:	33330000 8888ffff 00010888 00084200     ..33.........B..
    13fc:	00000952 00000000 00650000 000001e5     R.........e.....
    140c:	01780020 01300000 00000010 00003300      .x...0......3..
    141c:	040c0000 00000000 00020000 20800000     ............... 
    142c:	000780f8 000780f8 00000200 00040000     ................
    143c:	00400003 00000000 00000000 00010309     ..@.............
    144c:	00000000 00800000 00000000 00000003     ................
	...
    1464:	0000000b 00000000 00800000 01002004     ............. ..
    1474:	00000008 00000000 00000000 00000001     ................
	...
    148c:	05014050 00005014 00180008 00050000     P@...P..........
	...
    14ac:	05010050 00005010 00000000 00000000     P....P..........
    14bc:	00430000 00030000 00010001 00000000     ..C.............
    14cc:	00010000 00000000 00000000 00000000     ................
	...

000014e8 <_init>:
    14e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    14ea:	bf00      	nop
    14ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
    14ee:	bc08      	pop	{r3}
    14f0:	469e      	mov	lr, r3
    14f2:	4770      	bx	lr

000014f4 <_fini>:
    14f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    14f6:	bf00      	nop
    14f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    14fa:	bc08      	pop	{r3}
    14fc:	469e      	mov	lr, r3
    14fe:	4770      	bx	lr

00001500 <__frame_dummy_init_array_entry>:
    1500:	0425 0000                                   %...

00001504 <__do_global_dtors_aux_fini_array_entry>:
    1504:	0411 0000 0000 0000 0000 0000               ............
